{
  "hash": "b46d7288e0f4c4be4625dc6ca713f16c",
  "result": {
    "markdown": "---\ntitle: \"Challenge 3\"\nauthor: \"Shaunak Padhye\"\ndescription: \"Tidy Data: Pivoting\"\ndate: \"05/12/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_3\n  - Shaunak Padhye\n  - australian_marriage\n---\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(tidyr)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n## Read in data\n\nFor this challenge, we will be using the following dataset:\n\n-   australian_marriage\\*.xls ⭐⭐⭐\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvotes <- read_excel(\"_data/australian_marriage_law_postal_survey_2017_-_response_final.xls\",\n                        sheet=\"Table 2\",\n                        skip=6)\ncolnames(votes) <- c(\"District\", \"Yes\", \"del1\", \"No\", rep(\"del2\", 6), \"Illegible\", \"del3\", \"No Response\", rep(\"del4\", 3))\nvotes <- votes[, !grepl(\"del\", names(votes))]\nvotes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 184 × 5\n   District                    Yes    No Illegible `No Response`\n   <chr>                     <dbl> <dbl>     <dbl>         <dbl>\n 1 New South Wales Divisions    NA    NA        NA            NA\n 2 Banks                     37736 46343       247         20928\n 3 Barton                    37153 47984       226         24008\n 4 Bennelong                 42943 43215       244         19973\n 5 Berowra                   48471 40369       212         16038\n 6 Blaxland                  20406 57926       220         25883\n 7 Bradfield                 53681 34927       202         17261\n 8 Calare                    54091 35779       285         25342\n 9 Chifley                   32871 46702       263         28180\n10 Cook                      47505 38804       229         18713\n# ℹ 174 more rows\n```\n:::\n:::\n\n\nWe can see that this dataset will require some cleaning before it can be used.\nWe will start with removing the NA values from the \"District\" column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvotes <- votes[!is.na(votes$District),]\nvotes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 174 × 5\n   District                    Yes    No Illegible `No Response`\n   <chr>                     <dbl> <dbl>     <dbl>         <dbl>\n 1 New South Wales Divisions    NA    NA        NA            NA\n 2 Banks                     37736 46343       247         20928\n 3 Barton                    37153 47984       226         24008\n 4 Bennelong                 42943 43215       244         19973\n 5 Berowra                   48471 40369       212         16038\n 6 Blaxland                  20406 57926       220         25883\n 7 Bradfield                 53681 34927       202         17261\n 8 Calare                    54091 35779       285         25342\n 9 Chifley                   32871 46702       263         28180\n10 Cook                      47505 38804       229         18713\n# ℹ 164 more rows\n```\n:::\n:::\n\n\nNow we can remove all the rows where the District value contains the string \"(Total)\" or starts with the character '('. These rows provide aggregated data which can be calculated using the rest of the dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvotes <- votes[!grepl(\"(Total)\", votes$District), ]\nvotes <- votes[!grepl(\"^\\\\(\", votes$District), ]\nvotes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 160 × 5\n   District                    Yes    No Illegible `No Response`\n   <chr>                     <dbl> <dbl>     <dbl>         <dbl>\n 1 New South Wales Divisions    NA    NA        NA            NA\n 2 Banks                     37736 46343       247         20928\n 3 Barton                    37153 47984       226         24008\n 4 Bennelong                 42943 43215       244         19973\n 5 Berowra                   48471 40369       212         16038\n 6 Blaxland                  20406 57926       220         25883\n 7 Bradfield                 53681 34927       202         17261\n 8 Calare                    54091 35779       285         25342\n 9 Chifley                   32871 46702       263         28180\n10 Cook                      47505 38804       229         18713\n# ℹ 150 more rows\n```\n:::\n:::\n\n\nWe can observe that some values in the District column contain Divisions. These rows define the Divisions of the Districts given in the underlying rows.\n\n::: {.cell}\n\n```{.r .cell-code}\nvotes[grep(\"Divisions\", votes$District), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 5\n  District                                 Yes    No Illegible `No Response`\n  <chr>                                  <dbl> <dbl>     <dbl>         <dbl>\n1 New South Wales Divisions                 NA    NA        NA            NA\n2 Victoria Divisions                        NA    NA        NA            NA\n3 Queensland Divisions                      NA    NA        NA            NA\n4 South Australia Divisions                 NA    NA        NA            NA\n5 Western Australia Divisions               NA    NA        NA            NA\n6 Tasmania Divisions                        NA    NA        NA            NA\n7 Northern Territory Divisions              NA    NA        NA            NA\n8 Australian Capital Territory Divisions    NA    NA        NA            NA\n```\n:::\n:::\n\n\nIdeally these values shouldn't exist in the Districts column, since they aren't districts. However, we cannot remove these rows either as they contain useful information that we might want to retain. For this reason we will create a new variable (column) which will store the Division of the DIstrict in the row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvotes$Division <- ifelse(grepl(\"Divisions\", votes$District), votes$District, NA)\n#votes$Division <- tidyr::fill(votes$Division, .direction = \"down\")\nfor (i in 2:length(votes$Division)) {\n  if (is.na(votes$Division[i])) {\n    votes$Division[i] <- votes$Division[i-1]\n  }\n}\nvotes <- votes[!grepl(\"Divisions\", votes$District), ]\nvotes <- na.omit(votes)\nvotes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 × 6\n   District    Yes    No Illegible `No Response` Division                 \n   <chr>     <dbl> <dbl>     <dbl>         <dbl> <chr>                    \n 1 Banks     37736 46343       247         20928 New South Wales Divisions\n 2 Barton    37153 47984       226         24008 New South Wales Divisions\n 3 Bennelong 42943 43215       244         19973 New South Wales Divisions\n 4 Berowra   48471 40369       212         16038 New South Wales Divisions\n 5 Blaxland  20406 57926       220         25883 New South Wales Divisions\n 6 Bradfield 53681 34927       202         17261 New South Wales Divisions\n 7 Calare    54091 35779       285         25342 New South Wales Divisions\n 8 Chifley   32871 46702       263         28180 New South Wales Divisions\n 9 Cook      47505 38804       229         18713 New South Wales Divisions\n10 Cowper    57493 38317       315         25197 New South Wales Divisions\n# ℹ 140 more rows\n```\n:::\n:::\n\n\n\n### Briefly describe the data\n\nThis data set provides results of a survey held in Australia regarding same sex marriages. Participants had to give either a \"Yes\" or a \"No\" response. Many participants were unclear on their response hence the data set also has a column for that. Many participants failed to respond and hence that is also considered in the data set. The voting results have been grouped by Divisions and Districts in Australia.\n\nAfter some initial pre-processing, we can see that the data set has 6 columns, and 150 rows. We can observe that the following columns: Yes, No, Illegible, No Response; are the results of the same survey and hence can be pivoted into a single column.\n\n## Anticipate the End Result\n\nOur dataset has $150$ rows and $6$ variables. 2 of the variables are used to identify a case, so we will be pivoting $6-2$ variables into a longer format where the $6-2$ variable names will move into the `names_to` variable and the current values in each of those columns will move into the `values_to` variable. Therefore, we would expect $150 * (6-2) = 600$ rows in the pivoted dataframe. We will have $2$ unpivoted variables, plus the two new variable defined by the `names_to` and the `values_to` parameter of the pivot function. Hence we end up with $4$ variables in the pivoted dataset.\n\nTherefore, we expect that the dimensions of the pivoted dataset will be $600 * 4$.\n\n## Pivot the Data\n\nNow we will pivot the data, and compare our pivoted data dimensions to the dimensions calculated above as a \"sanity\" check.\n\n\n::: {.cell tbl-cap='Pivoted Example'}\n\n```{.r .cell-code}\nvotes_piv<-pivot_longer(votes, cols = Yes:`No Response`,\n                 names_to=\"Response\",\n                 values_to = \"Count\")\nvotes_piv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 600 × 4\n   District  Division                  Response    Count\n   <chr>     <chr>                     <chr>       <dbl>\n 1 Banks     New South Wales Divisions Yes         37736\n 2 Banks     New South Wales Divisions No          46343\n 3 Banks     New South Wales Divisions Illegible     247\n 4 Banks     New South Wales Divisions No Response 20928\n 5 Barton    New South Wales Divisions Yes         37153\n 6 Barton    New South Wales Divisions No          47984\n 7 Barton    New South Wales Divisions Illegible     226\n 8 Barton    New South Wales Divisions No Response 24008\n 9 Bennelong New South Wales Divisions Yes         42943\n10 Bennelong New South Wales Divisions No          43215\n# ℹ 590 more rows\n```\n:::\n:::\n\n\nDimensions of the pivoted dataset:\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(votes_piv)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 600   4\n```\n:::\n:::\n\n\nYes, once it is pivoted long, our resulting data are $600*4$ - exactly what we expected!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}